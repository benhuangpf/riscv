// // Generated by CIRCT unknown git version
// // Standard header to adapt well known macros to our needs.
// `ifndef RANDOMIZE
//   `ifdef RANDOMIZE_REG_INIT
//     `define RANDOMIZE
//   `endif // RANDOMIZE_REG_INIT
// `endif // not def RANDOMIZE
// `ifndef RANDOMIZE
//   `ifdef RANDOMIZE_MEM_INIT
//     `define RANDOMIZE
//   `endif // RANDOMIZE_MEM_INIT
// `endif // not def RANDOMIZE

// // RANDOM may be set to an expression that produces a 32-bit random unsigned value.
// `ifndef RANDOM
//   `define RANDOM $random
// `endif // not def RANDOM

// // Users can define 'PRINTF_COND' to add an extra gate to prints.
// `ifndef PRINTF_COND_
//   `ifdef PRINTF_COND
//     `define PRINTF_COND_ (`PRINTF_COND)
//   `else  // PRINTF_COND
//     `define PRINTF_COND_ 1
//   `endif // PRINTF_COND
// `endif // not def PRINTF_COND_

// // Users can define 'ASSERT_VERBOSE_COND' to add an extra gate to assert error printing.
// `ifndef ASSERT_VERBOSE_COND_
//   `ifdef ASSERT_VERBOSE_COND
//     `define ASSERT_VERBOSE_COND_ (`ASSERT_VERBOSE_COND)
//   `else  // ASSERT_VERBOSE_COND
//     `define ASSERT_VERBOSE_COND_ 1
//   `endif // ASSERT_VERBOSE_COND
// `endif // not def ASSERT_VERBOSE_COND_

// // Users can define 'STOP_COND' to add an extra gate to stop conditions.
// `ifndef STOP_COND_
//   `ifdef STOP_COND
//     `define STOP_COND_ (`STOP_COND)
//   `else  // STOP_COND
//     `define STOP_COND_ 1
//   `endif // STOP_COND
// `endif // not def STOP_COND_

// // Users can define INIT_RANDOM as general code that gets injected into the
// // initializer block for modules with registers.
// `ifndef INIT_RANDOM
//   `define INIT_RANDOM
// `endif // not def INIT_RANDOM

// // If using random initialization, you can also define RANDOMIZE_DELAY to
// // customize the delay used, otherwise 0.002 is used.
// `ifndef RANDOMIZE_DELAY
//   `define RANDOMIZE_DELAY 0.002
// `endif // not def RANDOMIZE_DELAY

// // Define INIT_RANDOM_PROLOG_ for use in our modules below.
// `ifndef INIT_RANDOM_PROLOG_
//   `ifdef RANDOMIZE
//     `ifdef VERILATOR
//       `define INIT_RANDOM_PROLOG_ `INIT_RANDOM
//     `else  // VERILATOR
//       `define INIT_RANDOM_PROLOG_ `INIT_RANDOM #`RANDOMIZE_DELAY begin end
//     `endif // VERILATOR
//   `else  // RANDOMIZE
//     `define INIT_RANDOM_PROLOG_
//   `endif // RANDOMIZE
// `endif // not def INIT_RANDOM_PROLOG_

// `define SIZE_TEXT 2048  // You can change the size

// module ICache(
//   input         clock,
//                 reset,
//                 auto_master_out_a_ready,
//                 auto_master_out_d_valid,
//   input  [2:0]  auto_master_out_d_bits_opcode,
//   input  [3:0]  auto_master_out_d_bits_size,
//   input  [31:0] auto_master_out_d_bits_data,
//   input         auto_master_out_d_bits_corrupt,
//                 io_req_valid,
//   input  [31:0] io_req_bits_addr,
//                 io_s1_paddr,
//   input         io_s1_kill,
//                 io_s2_kill,
//                 io_invalidate,
//   output        auto_master_out_a_valid,
//   output [31:0] auto_master_out_a_bits_address,
//   output        io_resp_valid,
//   output [31:0] io_resp_bits_data,
//   output        io_resp_bits_replay,
//                 io_resp_bits_ae
// );


//     integer i;
  
//     // For mem_I
//     // wire [31:0] mem_addr_I ;
//     wire  [31:0] mem_rdata_I;
//     reg  [31:0] mem_text_offset;

//     reg valid_s1, valid_s2;
//     reg  [31:0] rdata_s1, rdata_s2;

//     assign io_resp_bits_replay = 1'b0;
//     assign io_resp_bits_ae = 1'b0;
//     assign io_resp_valid = valid_s2;
//     assign io_resp_bits_data = rdata_s2;

//     memory #(.word_depth(`SIZE_TEXT)) mem_text(
//         .clk(clock),
//         .rst_n(reset),
//         .wen(1'b0),
//         .a(io_req_bits_addr),
//         .d(32'd0),
//         .q(mem_rdata_I),
//         .offset(mem_text_offset));

//     initial begin
//         mem_text_offset = 32'h80000000;   
//     end

//     always @(posedge clock) begin
//       if (reset) begin
//         valid_s1 <= 1'b0;
//         valid_s2 <= 1'b0;
//         rdata_s1 <= 32'h0;
//         rdata_s2 <= 32'h0;
//       end
//       else begin
//         valid_s1 <= io_req_valid;
//         valid_s2 <= valid_s1;
//         rdata_s1 <= mem_rdata_I;
//         rdata_s2 <= rdata_s1;
//       end
//     end
// endmodule

